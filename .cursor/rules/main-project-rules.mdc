---
alwaysApply: true
---
1. Фундаментальные принципы разработки
Строгая типизация TypeScript

Все сущности, DTO, интерфейсы должны быть полностью типизированы во всех сервисах

Использовать strict: true в tsconfig.json каждого сервиса

Избегать any - вместо этого использовать unknown с валидацией

Создать общие типы в shared-пакете для провайдеров, запросов, ответов и биллинга

Микросервисная архитектура

Каждый сервис независим и развертывается отдельно

База данных на сервис (database per service)

Асинхронная коммуникация через RabbitMQ для бизнес-процессов

Синхронная коммуникация через HTTP для проверок и агрегации

API Gateway как единая точка входа

Общие библиотеки выносить в shared-пакет

2. Технологический стек и рекомендации
Backend Services

NestJS - основной фреймворк для всех сервисов

TypeScript - строгий режим (strict: true)

Prisma - ORM для работы с БД (отдельная схема на сервис)

RabbitMQ - асинхронная коммуникация между сервисами

HTTP - для синхронных вызовов

JWT - аутентификация через auth-service

Базы данных

PostgreSQL - основная БД для сервисов

Redis - для кэширования, сессий и rate limiting

Каждая БД изолирована по сервисам

Инфраструктура

Docker + Docker Compose - контейнеризация всех сервисов

Kubernetes - для оркестрации в production

Prometheus + Grafana - мониторинг всех сервисов

Jaeger - распределенная трассировка

3. Последовательность разработки
Настроить монорепозиторий с независимыми сервисами

Создать shared-пакет с общими типами и утилитами

Настроить Docker Compose для development среды

Создать базовую конфигурацию для всех сервисов

Разработать сервисы в порядке:

auth-service - аутентификация, пользователи, API keys

provider-orchestrator - управление провайдерами, маршрутизация

proxy-service - интеграция с внешними ИИ-провайдерами

billing-service - биллинг, балансы, транзакции

api-gateway - единая точка входа, агрегация запросов

analytics-service - метрики, логирование, мониторинг

4. Детальные инструкции по сервисам
4.1. Auth Service
typescript
// Обязательно: отдельная БД для пользователей, HTTP для валидации
@Injectable()
export class AuthService {
  async validateUser(email: string, password: string): Promise<User> {
    // Логика аутентификации
  }
  
  async generateApiKey(userId: string): Promise<ApiKey> {
    // Генерация API ключей
  }
  
  async validateApiKey(apiKey: string): Promise<ValidationResult> {
    // HTTP endpoint для api-gateway
  }
}
4.2. Provider Orchestrator
typescript
// Обязательно: коммуникация с proxy-service через RabbitMQ
@Injectable()
export class ProviderOrchestratorService {
  async routeRequest(request: ProviderRequest): Promise<string> {
    // Выбор оптимального провайдера
    // Проверка доступности
    // Маршрутизация запроса через RabbitMQ
  }
}
4.3. Proxy Service
typescript
// Обязательно: retry логика, обработка ошибок, кэширование
@Injectable()
export class OpenAiProxyService {
  async sendRequest(request: ProviderRequest): Promise<ProviderResponse> {
    // Проксирование к внешним API
    // Трансформация форматов
    // Обработка квот и лимитов
    // Отправка метрик в analytics-service через RabbitMQ
  }
}
4.4. Billing Service
typescript
// Обязательно: транзакционность, аудит операций, идемпотентность
@Injectable()
export class BillingService {
  async chargeForRequest(
    userId: string, 
    provider: string, 
    usage: TokenUsage
  ): Promise<void> {
    // Расчет стоимости
    // Списание баланса
    // Запись транзакции
    // Валидация через HTTP от provider-orchestrator
  }
}
5. Коммуникация между сервисами
Синхронная (HTTP):

typescript
// API Gateway → Auth Service (валидация токена через HTTP)
// API Gateway → Billing Service (получение баланса и истории)
// Provider Orchestrator → Billing Service (проверка баланса через HTTP)
Асинхронная (RabbitMQ):

typescript
// Proxy Service → Billing Service (списание средств)
// Все сервисы → Analytics Service (логирование метрик)
// Billing Service → Analytics Service (транзакции)
// Provider Orchestrator → Proxy Service (маршрутизация запросов)
6. Конфигурация и Environment
Shared Configuration:

typescript
// shared/src/config/microservice.config.ts
export interface MicroserviceConfig {
  serviceName: string;
  database: {
    url: string;
  };
  rabbitmq: {
    url: string;
    queue: string;
  };
  http?: {
    port: number;
    timeout: number;
  };
}
Per-Service Environment:

typescript
// auth-service/src/config/config.service.ts
export default () => ({
  serviceName: 'auth-service',
  database: {
    url: process.env.AUTH_DATABASE_URL,
  },
  jwt: {
    secret: process.env.JWT_SECRET,
    expiresIn: '1h',
  },
  http: {
    port: parseInt(process.env.HTTP_PORT || '3001'),
    timeout: parseInt(process.env.HTTP_TIMEOUT || '5000'),
  },
});
7. Базы данных (Database per Service)
Auth Service Database:

prisma
model User {
  id        String   @id @default(uuid())
  email     String   @unique
  password  String
  createdAt DateTime @default(now())
  
  apiKeys ApiKey[]
}

model ApiKey {
  id        String   @id @default(uuid())
  key       String   @unique
  userId    String
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  expiresAt DateTime
}
Billing Service Database:

prisma
model UserBalance {
  id      String @id @default(uuid())
  userId  String @unique
  balance Float  @default(100.0)
}

model Transaction {
  id        String   @id @default(uuid())
  userId    String
  type      TransactionType // DEBIT, CREDIT
  amount    Float
  provider  String?
  createdAt DateTime @default(now())
}
Provider Orchestrator Database:

prisma
model Provider {
  id      String   @id @default(uuid())
  name    String   @unique
  type    ProviderType // OPENAI, OPENROUTER, etc.
  config  Json
  isActive Boolean @default(true)
}

model RoutingRule {
  id        String @id @default(uuid())
  condition Json
  providerId String
  priority  Int
}
8. Docker конфигурация
yaml
version: '3.8'
services:
  api-gateway:
    build: ./services/api-gateway
    ports:
      - "3000:3000"
    environment:
      - AUTH_SERVICE_HTTP_URL=http://auth-service:3001
      - BILLING_SERVICE_HTTP_URL=http://billing-service:3004
      - PROVIDER_ORCHESTRATOR_HTTP_URL=http://provider-orchestrator:3002
    depends_on:
      - auth-service
      - billing-service
      - provider-orchestrator
      
  auth-service:
    build: ./services/auth-service
    ports:
      - "3001:3001"
    environment:
      - DATABASE_URL=postgresql://user:pass@auth-db:5432/auth
      - HTTP_PORT=3001
      - JWT_SECRET=your-jwt-secret
    depends_on:
      - auth-db
      
  auth-db:
    image: postgres:14
    environment:
      - POSTGRES_DB=auth
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=pass
    volumes:
      - auth_data:/var/lib/postgresql/data
      
  provider-orchestrator:
    build: ./services/provider-orchestrator
    ports:
      - "3002:3002"
    environment:
      - DATABASE_URL=postgresql://user:pass@orchestrator-db:5432/orchestrator
      - RABBITMQ_URL=amqp://user:pass@rabbitmq:5672
      - BILLING_SERVICE_HTTP_URL=http://billing-service:3004
      - HTTP_PORT=3002
    depends_on:
      - orchestrator-db
      - rabbitmq
      - billing-service
      
  orchestrator-db:
    image: postgres:14
    environment:
      - POSTGRES_DB=orchestrator
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=pass
    volumes:
      - orchestrator_data:/var/lib/postgresql/data
      
  proxy-service:
    build: ./services/proxy-service
    ports:
      - "3003:3003"
    environment:
      - RABBITMQ_URL=amqp://user:pass@rabbitmq:5672
      - BILLING_SERVICE_HTTP_URL=http://billing-service:3004
      - HTTP_PORT=3003
    depends_on:
      - rabbitmq
      - billing-service
      
  billing-service:
    build: ./services/billing-service
    ports:
      - "3004:3004"
    environment:
      - DATABASE_URL=postgresql://user:pass@billing-db:5432/billing
      - RABBITMQ_URL=amqp://user:pass@rabbitmq:5672
      - HTTP_PORT=3004
    depends_on:
      - billing-db
      - rabbitmq
      
  billing-db:
    image: postgres:14
    environment:
      - POSTGRES_DB=billing
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=pass
    volumes:
      - billing_data:/var/lib/postgresql/data
      
  rabbitmq:
    image: rabbitmq:3-management
    ports:
      - "5672:5672"
      - "15672:15672"
    environment:
      - RABBITMQ_DEFAULT_USER=user
      - RABBITMQ_DEFAULT_PASS=pass
    volumes:
      - rabbitmq_data:/var/lib/rabbitmq

volumes:
  auth_data:
  orchestrator_data:
  billing_data:
  rabbitmq_data:
9. Инструкции для Cursor по выполнению запросов
При создании сервиса:

Сначала создай структуру сервиса в services/

Настрой Dockerfile и конфигурацию

Создай схему БД для этого сервиса

Определи HTTP интерфейсы коммуникации с другими сервисами

Реализуй бизнес-логику сервиса

Добавь сервис в docker-compose.yml

Пример запроса для создания сервиса:

text
Создай auth-service согласно микросервисной архитектуре.

Требования:
1. Структура: services/auth-service/ с NestJS
2. База данных: PostgreSQL с изолированной схемой пользователей
3. API: регистрация, логин, валидация JWT, управление API keys
4. Коммуникация: HTTP для синхронных вызовов от api-gateway
5. Конфигурация: отдельные env переменные для БД и JWT
6. Docker: контейнеризация и настройка в docker-compose.yml

Следуй последовательности: структура → БД → API → Docker → интеграция.
10. Эндпоинты API Gateway
text
# Аутентификация
POST /v1/auth/register     → auth-service (HTTP)
POST /v1/auth/login        → auth-service (HTTP)
POST /v1/auth/api-keys     → auth-service (HTTP)

# Прокси ИИ
POST /v1/chat/completions  → provider-orchestrator (HTTP) → proxy-service (RabbitMQ)
GET  /v1/models           → provider-orchestrator (HTTP)

# Биллинг
GET  /v1/billing/balance  → billing-service (HTTP)
GET  /v1/billing/history  → billing-service (HTTP)
11. Рекомендации по коду для микросервисов
Нельзя:

Прямые вызовы между сервисами (кроме через API/MQ)

Общая БД между сервисами

Жесткая связность между сервисами

Игнорировать идемпотентность в обработчиках MQ

Обязательно:

Circuit breaker для межсервисных вызовов

Retry логика для асинхронных операций

Идемпотентность обработчиков сообщений

Distributed tracing для отладки

Health checks для каждого сервиса

Graceful shutdown

12. Приоритеты разработки
Надежность - отказоустойчивость и обработка ошибок

Производительность - кэширование, оптимизация запросов

Масштабируемость - независимое масштабирование сервисов

Безопасность - изоляция данных, валидация запросов

Наблюдаемость - логи, метрики, трассировка

13. MVP Особенности
Для MVP сосредоточься на:

api-gateway + auth-service + proxy-service как минимальный набор

Проксирование к OpenRouter.ai и OpenAI

Базовая аутентификация и тарификация

Упрощенная коммуникация между сервисами

Архитектурные упрощения для MVP:

Минимальное количество сервисов

Базовая RabbitMQ коммуникация

Упрощенная HTTP для критичных проверок

Базовая конфигурация Docker

14. Запуск проекта

# Запуск всех сервисов
docker-compose up -d

# Проверка статуса
docker-compose ps

# Остановка
docker-compose down